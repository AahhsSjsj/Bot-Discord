"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoiceClient = void 0;
const mongoose_1 = __importDefault(require("mongoose"));
const discord_js_1 = require("discord.js");
const ms_1 = __importDefault(require("ms"));
class VoiceClient {
    client;
    options;
    schemas = {
        timer: mongoose_1.default.model("djs-voice-timers", new mongoose_1.default.Schema({
            User: String,
            Start: Number,
            Guild: String,
        })),
        user: mongoose_1.default.model("djs-voice-users", new mongoose_1.default.Schema({
            User: String,
            Time: Number,
            Guild: String,
        })),
    };
    constructor(options) {
        if (mongoose_1.default.connection.readyState === 1)
            return;
        if (!options.mongooseConnectionString)
            throw new Error("There is no established  connection with mongoose and a mongoose connection is required!");
        mongoose_1.default.connect(options.mongooseConnectionString, {
            useFindAndModify: true,
            useUnifiedTopology: true,
            useNewUrlParser: true,
        });
        this.options = options;
        this.client = options.client;
    }
    /**
     * @description Put this inside your voiceStateChange client event!
     * @param {VoiceState} oldState discord.js's VoiceState
     * @param {VoiceState} newState discord.js's VoiceState
     * @returns {Promise<void>}
     */
    async startListener(oldState, newState) {
        if (newState.member.user.bot && !this.options.allowBots)
            return;
        const userID = newState.member.id;
        const guildID = newState.guild.id;
        if (newState.channel &&
            !(await this.schemas.timer.findOne({
                User: userID,
                Guild: guildID,
            }))) {
            if (this.options.debug)
                console.log(`${newState.member.user.tag} has joined a voice channel`);
            new this.schemas.timer({
                User: userID,
                Start: Date.now(),
                Guild: guildID,
            }).save();
        }
        if (oldState.channel?.id && !newState.channel?.id) {
            if (this.options.debug)
                console.log(`${newState.member.user.tag} has left a voice channel`);
            this.schemas.timer.findOne({ User: userID, Guild: guildID }, async (err, timerData) => {
                if (!timerData)
                    return;
                this.schemas.user.findOne({ User: userID, Guild: guildID }, async (err, userData) => {
                    const Time = Date.now() - timerData.Start;
                    timerData.delete();
                    if (this.options.debug)
                        console.log(ms_1.default(Time, { long: true }) +
                            ` for ${newState.member.user.tag}`);
                    if (!userData) {
                        new this.schemas.user({
                            User: userID,
                            Time,
                            Guild: guildID,
                        }).save();
                    }
                    else {
                        userData.Time += Time;
                        userData.save();
                    }
                });
            });
        }
    }
    /**
     * @description Fetching and sorting raw data from guild
     * @param {Message} message discord.js's message class
     */
    async sortUsers(message) {
        const userLeaderboard = await this.schemas.user
            .find({ Guild: message.guild.id })
            .sort({ Time: -1 });
        return userLeaderboard;
    }
    /**
     * @description Gives you all the data you need about a user
     * @param {Message} message discord.js's Message class
     * @param {User} user discord.js's User class
     */
    async getUserData(message, user) {
        const data = await this.schemas.user.findOne({
            Guild: message.guild.id,
            User: user.id,
        });
        if (!data)
            return null;
        const position = (await this.sortUsers(message)).findIndex((x) => x.User === user.id);
        const { User, Time, Guild, _id } = data;
        return { _id, User, Time, Guild, position };
    }
    /**
     * @description Generating a leaderbord
     */
    async generateLeaderboard(options) {
        let { message, title, color, top, thumbnail } = options;
        const data = await this.sortUsers(message);
        let i = 1;
        const topTen = data.slice(0, top || 10);
        if (this.options.debug)
            console.log(topTen);
        return new discord_js_1.MessageEmbed()
            .setTitle(title || `Leaderboard in **${message.guild.name}**`)
            .setColor(color || "RANDOM")
            .setThumbnail(thumbnail || null)
            .setDescription(topTen
            .map((x) => {
            return `\`${i++}\` <@${x.User}> (${ms_1.default(x.Time)})`;
        })
            .join("\n\n"));
    }
    /**
     * @description Reset the entire voice system database!
     * @param {Message} message discord.js's Message class
     */
    async reset(message) {
        await this.schemas.timer.deleteMany({ Guild: message.guild.id });
        await this.schemas.user.deleteMany({ Guild: message.guild.id });
    }
    /**
     * @description Change a user's voice channel time in a specific guild
     * @param message discord.js's Message class
     * @param user discord.js's User class
     * @param time Time you want to change in miliseconds
     */
    setTime(message, user, time) {
        this.schemas.user.findOne({ Guild: message.guild.id, User: user.id }, async (err, data) => {
            if (err && this.options.debug)
                return console.log(err);
            data.Time = time;
            data.save();
        });
    }
    /**
     * @description Chunk arrays into smaller arrays
     */
    chunkArrays(arr, size) {
        const array = [];
        for (let i = 0; i < arr.length; i += size) {
            array.push(arr.slice(i, i + size));
        }
        return array;
    }
}
exports.VoiceClient = VoiceClient;
//# sourceMappingURL=index.js.map